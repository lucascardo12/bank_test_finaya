# Projeto PIX Wallet

Este projeto simula um sistema simplificado de carteiras digitais com suporte a:

- Transfer√™ncias via PIX
- Webhook de confirma√ß√£o do arranjo PIX
- Controle de idempot√™ncia
- Hist√≥rico de saldo por data/hora
- Opera√ß√µes de dep√≥sito e saque

[![Quality gate](https://sonarcloud.io/api/project_badges/quality_gate?project=lucascardo12_bank_test_finaya)](https://sonarcloud.io/summary/new_code?id=lucascardo12_bank_test_finaya)

---

## üìã √çndice

- [Funcionalidades Principais](#-funcionalidades-principais)
- [Instala√ß√£o e Execu√ß√£o](#-instala√ß√£o-e-execu√ß√£o)
- [Testes](#-testes)
- [Swagger/OpenAPI](#-swaggeropenapi)
- [Spring Boot Actuator](#-spring-boot-actuator)
- [Decis√µes de Design](#-decis√µes-de-design)
- [Trade-offs e Compromissos](#-trade-offs-e-compromissos)
- [Tecnologias](#-tecnologias)
- [Estrutura do Projeto](#-estrutura-do-projeto)
- [Licen√ßa](#-licen√ßa)

---

## üöÄ Funcionalidades Principais

### **1. Criar Carteira**

`POST /wallets`

Cria uma nova carteira no sistema.

**Body:**

```json
{
  "userId": "user123"
}
```

---

### **2. Consultar Saldo Hist√≥rico**

`GET /wallets/{id}/balance?at=2025-10-09T15:00:00Z`

Retorna o saldo da carteira em um instante espec√≠fico do tempo. Aceita `LocalDateTime` como par√¢metro no formato
ISO-8601.

**Exemplo sem par√¢metro (saldo atual):**

```
GET /wallets/{id}/balance
```

**Exemplo com data/hora:**

```
GET /wallets/{id}/balance?at=2025-10-09T15:00:00Z
```

---

### **3. Transfer√™ncia PIX**

`POST /pix/transfers`

**Headers:**

```
Idempotency-Key: <uuid>
```

**Body:**

```json
{
  "fromWalletId": "string",
  "toPixKey": "string",
  "amount": 100.00
}
```

**Resposta:**

```json
{
  "endToEndId": "E2E123",
  "status": "PENDING"
}
```

---

### **4. Webhook do Arranjo PIX**

`POST /pix/webhook`

Idempotente por `eventId`. Simula a confirma√ß√£o do Banco Central no fluxo PIX.

**Body:**

```json
{
  "endToEndId": "string",
  "eventId": "string",
  "eventType": "RECEIVED | CONFIRMED",
  "occurredAt": "2025-01-01T10:00:00Z"
}
```

---

### **5. Dep√≥sito e Saque**

`POST /wallets/{id}/deposit`
`POST /wallets/{id}/withdraw`

**Body:**

```json
{
  "amount": 100.00
}
```

---

### **6. Registrar Chave PIX**

`POST /wallets/{id}/pix-keys`

**Body:**

```json
{
  "key": "chave-pix-exemplo"
}
```

---

## üì¶ Instala√ß√£o e Execu√ß√£o

### Pr√©-requisitos

- **Java 21** ou superior
- **Gradle 8.x** (ou use o wrapper inclu√≠do: `./gradlew`)
- **PostgreSQL 15+** (ou use Docker Compose)

### Op√ß√£o 1: Usando Docker Compose (Recomendado)

1. **Clone o reposit√≥rio:**
   ```bash
   git clone <seu-repo>
   cd bank_test_finaya
   ```

2. **Inicie o PostgreSQL com Docker Compose:**
   ```bash
   docker-compose up -d
   ```

   **Nota:** As tabelas ser√£o criadas automaticamente pelo Hibernate na primeira execu√ß√£o. Se preferir criar
   manualmente, veja a se√ß√£o "Criar Tabelas Manualmente" na Op√ß√£o 2.

3. **Configure as vari√°veis de ambiente:**

   Crie um arquivo `.env` na raiz do projeto ou exporte as vari√°veis:
   ```bash
   export DB_URL=jdbc:postgresql://localhost:5432/bank_test
   export DB_USER=postgres
   export DB_PASSWORD=postgres
   export LOG_LEVEL=INFO
   ```

   **Windows (PowerShell):**
   ```powershell
   $env:DB_URL="jdbc:postgresql://localhost:5432/bank_test"
   $env:DB_USER="postgres"
   $env:DB_PASSWORD="postgres"
   $env:LOG_LEVEL="INFO"
   ```

4. **Execute a aplica√ß√£o:**
   ```bash
   ./gradlew bootRun
   ```

   **Windows:**
   ```cmd
   gradlew.bat bootRun
   ```

5. **Acesse a aplica√ß√£o:**
    - API: `http://localhost:8080`
    - Swagger UI: `http://localhost:8080/swagger-ui.html`
    - Actuator Health: `http://localhost:8080/actuator/health`
    - Actuator Metrics: `http://localhost:8080/actuator/metrics`

### Op√ß√£o 2: PostgreSQL Local

1. **Instale e configure o PostgreSQL localmente**

2. **Crie o banco de dados:**
   ```sql
   CREATE DATABASE bank_test;
   ```

3. **Configure as vari√°veis de ambiente** (mesmo processo da Op√ß√£o 1)

4. **Crie as tabelas manualmente (opcional):**

   Por padr√£o, o Hibernate cria as tabelas automaticamente (`spring.jpa.hibernate.ddl-auto=update`). Se preferir criar
   manualmente, execute os seguintes comandos SQL:

   ```sql
   -- Conecte-se ao banco de dados
   \c bank_test;

   -- Criar tabela wallet
   CREATE TABLE wallet (
       current_balance NUMERIC(38,2) NOT NULL,
       created_at TIMESTAMP(6) NOT NULL,
       updated_at TIMESTAMP(6) NOT NULL,
       id VARCHAR(255) NOT NULL,
       pix_key VARCHAR(255) UNIQUE,
       user_id VARCHAR(255) NOT NULL,
       PRIMARY KEY (id)
   );

   -- Criar tabela transaction
   CREATE TABLE transaction (
       amount NUMERIC(38,2) NOT NULL,
       created_at TIMESTAMP(6) NOT NULL,
       id BIGINT GENERATED BY DEFAULT AS IDENTITY,
       updated_at TIMESTAMP(6) NOT NULL,
       end_to_end_id VARCHAR(255) NOT NULL UNIQUE,
       pix_key VARCHAR(255),
       status VARCHAR(255) NOT NULL CHECK (status IN ('PENDING','CONFIRMED','REJECTED')),
       type VARCHAR(255) NOT NULL CHECK (type IN ('DEPOSIT','WITHDRAW','PIX_TRANSFER_OUT','PIX_TRANSFER_IN')),
       wallet_id VARCHAR(255),
       PRIMARY KEY (id)
   );

   -- Criar tabela event_pix
   CREATE TABLE event_pix (
       created_at TIMESTAMP(6) NOT NULL,
       id BIGINT GENERATED BY DEFAULT AS IDENTITY,
       occurred_at TIMESTAMP(6) NOT NULL,
       end_to_end_id VARCHAR(255) NOT NULL,
       event_id VARCHAR(255) NOT NULL UNIQUE,
       event_type VARCHAR(255) NOT NULL CHECK (event_type IN ('PENDING','CONFIRMED','REJECTED')),
       PRIMARY KEY (id)
   );
   ```

5. **Execute a aplica√ß√£o:**
   ```bash
   ./gradlew bootRun
   ```

### Op√ß√£o 3: Build e Executar JAR

1. **Build do projeto:**
   ```bash
   ./gradlew build
   ```

2. **Execute o JAR:**
   ```bash
   java -jar build/libs/bank-test-0.0.1-SNAPSHOT.jar
   ```

---

## üß™ Testes

### Executar todos os testes

```bash
./gradlew test
```

**Windows:**

```cmd
gradlew.bat test
```

### Executar testes com relat√≥rio

```bash
./gradlew test --info
```

Os relat√≥rios de teste estar√£o dispon√≠veis em: `build/reports/tests/test/index.html`

### Cobertura de testes

O projeto utiliza JUnit 5 para testes unit√°rios e de integra√ß√£o, cobrindo:

- Controllers (PixController, WalletController)
- Services (PixService, WalletsService, TransactionService)
- Exceptions personalizadas
- Entidades e enums

### Fluxo de Teste: Transfer√™ncia PIX

### Exemplo Pr√°tico de Teste Manual

Siga estes passos para testar uma transfer√™ncia PIX manualmente:

#### **Passo 1: Criar Wallets**

```bash
# Criar Wallet 1 (Origem)
curl -X POST http://localhost:8080/wallets \
  -H "Content-Type: application/json" \
  -d '{"userId": "user1"}'

# Resposta: {"id": "wallet1-uuid", "userId": "user1", "currentBalance": 0.00, ...}

# Criar Wallet 2 (Destino)
curl -X POST http://localhost:8080/wallets \
  -H "Content-Type: application/json" \
  -d '{"userId": "user2"}'

# Resposta: {"id": "wallet2-uuid", "userId": "user2", "currentBalance": 0.00, ...}
```

#### **Passo 2: Registrar Chave PIX na Wallet Destino**

```bash
curl -X POST http://localhost:8080/wallets/wallet2-uuid/pix-keys \
  -H "Content-Type: application/json" \
  -d '{"key": "pix-key-123"}'

# Resposta: {"id": "wallet2-uuid", "pixKey": "pix-key-123", ...}
```

#### **Passo 3: Adicionar Saldo na Wallet Origem**

```bash
curl -X POST http://localhost:8080/wallets/wallet1-uuid/deposit \
  -H "Content-Type: application/json" \
  -d '{"amount": 500.00}'

# Resposta: {"id": "wallet1-uuid", "currentBalance": 500.00, ...}
```

#### **Passo 4: Iniciar Transfer√™ncia PIX**

```bash
curl -X POST http://localhost:8080/pix/transfers \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: test-uuid-123" \
  -d '{
    "fromWalletId": "wallet1-uuid",
    "toPixKey": "pix-key-123",
    "amount": 100.00
  }'

# Resposta: {"endToEndId": "test-uuid-123", "status": "PENDING"}
```

#### **Passo 5: Confirmar Transfer√™ncia via Webhook**

```bash
curl -X POST http://localhost:8080/pix/webhook \
  -H "Content-Type: application/json" \
  -d '{
    "endToEndId": "test-uuid-123",
    "eventId": "event-456",
    "eventType": "CONFIRMED",
    "occurredAt": "2025-01-15T10:00:00Z"
  }'

# Resposta: 200 OK
```

#### **Passo 6: Verificar Saldos**

```bash
# Verificar saldo da Wallet 1 (Origem)
curl http://localhost:8080/wallets/wallet1-uuid/balance

# Resposta: {"walletId": "wallet1-uuid", "balance": 400.00}

# Verificar saldo da Wallet 2 (Destino)
curl http://localhost:8080/wallets/wallet2-uuid/balance

# Resposta: {"walletId": "wallet2-uuid", "balance": 100.00}
```

---

## üìö Swagger/OpenAPI

A documenta√ß√£o da API est√° dispon√≠vel atrav√©s do **SpringDoc OpenAPI**.

### Acessar Swagger UI

Ap√≥s iniciar a aplica√ß√£o, acesse:

- **Swagger UI:** `http://localhost:8080/swagger-ui.html`
- **OpenAPI JSON:** `http://localhost:8080/v3/api-docs`
- **OpenAPI YAML:** `http://localhost:8080/v3/api-docs.yaml`

### Funcionalidades do Swagger

- **Documenta√ß√£o interativa** de todos os endpoints
- **Teste de requisi√ß√µes** diretamente pela interface
- **Esquemas de dados** (DTOs) documentados
- **C√≥digos de resposta** e exemplos
- **Tags organizadas** por funcionalidade (Pix, Wallets)

### Exemplo de uso

1. Acesse `http://localhost:8080/swagger-ui.html`
2. Expanda o endpoint desejado (ex: `POST /pix/transfers`)
3. Clique em "Try it out"
4. Preencha os par√¢metros e body
5. Execute a requisi√ß√£o
6. Veja a resposta em tempo real

---

## üîç Spring Boot Actuator

O projeto utiliza o **Spring Boot Actuator** para monitoramento e gerenciamento da aplica√ß√£o.

### Acessar Endpoints do Actuator

Ap√≥s iniciar a aplica√ß√£o, os seguintes endpoints estar√£o dispon√≠veis:

- **Health Check:** `http://localhost:8080/actuator/health`
- **Info:** `http://localhost:8080/actuator/info`
- **Metrics:** `http://localhost:8080/actuator/metrics`
- **Prometheus:** `http://localhost:8080/actuator/prometheus`

### Endpoints Dispon√≠veis

#### **Health Check** (`/actuator/health`)

Verifica o status de sa√∫de da aplica√ß√£o, incluindo:

- Status geral da aplica√ß√£o
- Status do banco de dados
- Outros componentes configurados

**Exemplo de resposta:**

```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "PostgreSQL",
        "validationQuery": "isValid()"
      }
    }
  }
}
```

#### **Info** (`/actuator/info`)

Retorna informa√ß√µes sobre a aplica√ß√£o (configur√°vel via `application.properties`).

#### **Metrics** (`/actuator/metrics`)

Lista todas as m√©tricas dispon√≠veis. Para acessar uma m√©trica espec√≠fica:

- `http://localhost:8080/actuator/metrics/{metricName}`

**Exemplos de m√©tricas:**

- `http.server.requests` - Requisi√ß√µes HTTP
- `jvm.memory.used` - Uso de mem√≥ria JVM
- `process.cpu.usage` - Uso de CPU
- `hikaricp.connections.*` - M√©tricas do pool de conex√µes HikariCP
  - `hikaricp.connections.active` - Conex√µes ativas
  - `hikaricp.connections.idle` - Conex√µes ociosas
  - `hikaricp.connections.pending` - Conex√µes pendentes
  - `hikaricp.connections.timeout` - Timeouts de conex√£o
- `hibernate.*` - M√©tricas do Hibernate (queries, transa√ß√µes, etc.)
  - `hibernate.entities.*` - Estat√≠sticas de entidades
  - `hibernate.query.*` - Estat√≠sticas de queries
  - `hibernate.transaction.*` - Estat√≠sticas de transa√ß√µes

#### **Prometheus** (`/actuator/prometheus`)

Retorna m√©tricas no formato Prometheus para integra√ß√£o com sistemas de monitoramento.

### Configura√ß√£o

Os endpoints do Actuator est√£o configurados em `application.properties`:

```properties
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=when-authorized
management.info.env.enabled=true
# Habilitar estat√≠sticas do Hibernate para m√©tricas do banco de dados
spring.jpa.properties.hibernate.generate_statistics=true
```

---

## üèóÔ∏è Decis√µes de Design

### Arquitetura em Camadas (Layered Architecture)

O projeto segue uma arquitetura em camadas bem definida, separando responsabilidades:

#### **1. Camada de Dom√≠nio (`domain/`)**

- **Entidades:** Representam o modelo de neg√≥cio (WalletEntity, TransactionEntity, EventPixEntity)
- **Reposit√≥rios:** Interfaces que abstraem o acesso a dados
- **Servi√ßos:** L√≥gica de neg√≥cio pura, independente de frameworks
- **Exce√ß√µes:** Exce√ß√µes de dom√≠nio espec√≠ficas do neg√≥cio

**Benef√≠cios:**

- ‚úÖ Testabilidade: L√≥gica de neg√≥cio pode ser testada sem depend√™ncias externas
- ‚úÖ Manutenibilidade: Mudan√ßas na infraestrutura n√£o afetam o dom√≠nio
- ‚úÖ Reutiliza√ß√£o: Servi√ßos podem ser reutilizados em diferentes contextos

#### **2. Camada de Infraestrutura (`infrastructure/`)**

- **Controllers:** Endpoints REST, valida√ß√£o de entrada
- **DTOs:** Objetos de transfer√™ncia de dados, isolam a API do dom√≠nio

**Benef√≠cios:**

- ‚úÖ Desacoplamento: Mudan√ßas na API n√£o afetam o dom√≠nio
- ‚úÖ Versionamento: Facilita evolu√ß√£o da API sem quebrar contratos

#### **3. Camada de Configura√ß√£o (`configuration/`)**

- **ConfigurationBeans:** Configura√ß√£o expl√≠cita de depend√™ncias
- **Exception Handlers:** Tratamento centralizado de exce√ß√µes

**Benef√≠cios:**

- ‚úÖ Controle: Depend√™ncias expl√≠citas facilitam testes e manuten√ß√£o
- ‚úÖ Consist√™ncia: Respostas de erro padronizadas

### Atendimento aos Requisitos Funcionais

#### **RF1: Transfer√™ncias PIX**

- ‚úÖ Implementado via `PixService.transfer()`
- ‚úÖ Valida√ß√£o de saldo antes da transfer√™ncia
- ‚úÖ Cria√ß√£o de transa√ß√µes de d√©bito e cr√©dito
- ‚úÖ Status inicial `PENDING` aguardando confirma√ß√£o

#### **RF2: Webhook de Confirma√ß√£o**

- ‚úÖ Implementado via `PixService.processWebhook()`
- ‚úÖ Idempot√™ncia garantida por `eventId` √∫nico
- ‚úÖ Atualiza√ß√£o de saldos apenas quando `CONFIRMED`
- ‚úÖ Suporte a eventos `RECEIVED` e `CONFIRMED`

#### **RF3: Controle de Idempot√™ncia**

- ‚úÖ Transfer√™ncias: Via header `Idempotency-Key`
- ‚úÖ Webhooks: Via campo `eventId` √∫nico no banco
- ‚úÖ Transa√ß√µes: Via `endToEndId` √∫nico

#### **RF4: Hist√≥rico de Saldo**

- ‚úÖ Implementado via `TransactionService.amountByWalletIdAndDate()`
- ‚úÖ C√°lculo baseado em transa√ß√µes at√© a data especificada
- ‚úÖ Suporte a consulta de saldo atual ou hist√≥rico

#### **RF5: Dep√≥sito e Saque**

- ‚úÖ Implementado via `WalletsService.deposit()` e `withdraw()`
- ‚úÖ Valida√ß√£o de saldo para saques
- ‚úÖ Cria√ß√£o autom√°tica de transa√ß√µes

### Atendimento aos Requisitos N√£o-Funcionais

#### **RNF1: Performance**

- ‚úÖ Uso de √≠ndices √∫nicos no banco (`endToEndId`, `eventId`, `pixKey`)
- ‚úÖ Transa√ß√µes otimizadas com `@Transactional`
- ‚úÖ Queries diretas para c√°lculo de saldo hist√≥rico

#### **RNF2: Confiabilidade**

- ‚úÖ Idempot√™ncia em opera√ß√µes cr√≠ticas
- ‚úÖ Valida√ß√µes de neg√≥cio (saldo insuficiente, carteira n√£o encontrada)
- ‚úÖ Tratamento centralizado de exce√ß√µes

#### **RNF3: Manutenibilidade**

- ‚úÖ Separa√ß√£o clara de responsabilidades
- ‚úÖ C√≥digo test√°vel e coberto por testes
- ‚úÖ Uso de Lombok para reduzir boilerplate

#### **RNF4: Escalabilidade**

- ‚úÖ Arquitetura preparada para evolu√ß√£o
- ‚úÖ Reposit√≥rios podem ser substitu√≠dos (ex: Redis para cache)
- ‚úÖ Servi√ßos independentes facilitam distribui√ß√£o futura

---

## ‚öñÔ∏è Trade-offs e Compromissos

### 1. **Idempot√™ncia via Banco de Dados vs Redis**

**Decis√£o:** Implementa√ß√£o via banco de dados relacional (PostgreSQL)

**Motivo:**

- ‚úÖ Simplicidade: N√£o requer infraestrutura adicional
- ‚úÖ Consist√™ncia: Garantia ACID para opera√ß√µes cr√≠ticas
- ‚úÖ Persist√™ncia: Hist√≥rico completo de opera√ß√µes idempotentes

**Trade-off:**

- ‚ö†Ô∏è Performance: Redis seria mais r√°pido para leituras frequentes
- ‚ö†Ô∏è Escalabilidade: Em alta escala, Redis seria mais adequado

**Compromisso:** Para MVP/prot√≥tipo, banco relacional √© suficiente. Em produ√ß√£o com alto volume, considerar Redis para
cache de idempot√™ncia.

---

### 2. **C√°lculo de Saldo Hist√≥rico: Soma de Transa√ß√µes vs Snapshot**

**Decis√£o:** C√°lculo em tempo real somando transa√ß√µes at√© a data

**Motivo:**

- ‚úÖ Precis√£o: Sempre reflete o estado real
- ‚úÖ Simplicidade: N√£o requer tabela de snapshots
- ‚úÖ Flexibilidade: Funciona para qualquer data/hora

**Trade-off:**

- ‚ö†Ô∏è Performance: Em sistemas com milh√µes de transa√ß√µes, pode ser lento
- ‚ö†Ô∏è Carga no banco: Query agregada pode ser custosa

**Compromisso:** Para volumes moderados, a solu√ß√£o atual √© adequada. Em produ√ß√£o com alto volume, implementar snapshots
peri√≥dicos ou materialized views.

---

### 3. **Transa√ß√µes S√≠ncronas vs Ass√≠ncronas**

**Decis√£o:** Processamento s√≠ncrono de transfer√™ncias PIX

**Motivo:**

- ‚úÖ Simplicidade: Fluxo direto e f√°cil de debugar
- ‚úÖ Consist√™ncia: Resposta imediata ao usu√°rio
- ‚úÖ Adequado para MVP

**Trade-off:**

- ‚ö†Ô∏è Lat√™ncia: Usu√°rio aguarda confirma√ß√£o do webhook
- ‚ö†Ô∏è Escalabilidade: Em alta concorr√™ncia, pode sobrecarregar

**Compromisso:** Para o escopo atual, s√≠ncrono √© suficiente. Em produ√ß√£o, considerar fila de mensagens (RabbitMQ/Kafka)
para processamento ass√≠ncrono.

---

### 4. **Valida√ß√£o de Saldo: Otimista vs Pessimista**

**Decis√£o:** Valida√ß√£o otimista (check-then-act)

**Motivo:**

- ‚úÖ Performance: N√£o bloqueia outras opera√ß√µes
- ‚úÖ Simplicidade: C√≥digo mais direto

**Trade-off:**

- ‚ö†Ô∏è Race conditions: Em alta concorr√™ncia, pode haver saldo negativo
- ‚ö†Ô∏è Consist√™ncia: Requer locks ou versionamento

**Compromisso:** Para MVP, aceit√°vel. Em produ√ß√£o, implementar locks pessimistas ou versionamento otimista (optimistic
locking) na entidade Wallet.

---

### 5. **Configura√ß√£o Manual de Beans vs Auto-configura√ß√£o**

**Decis√£o:** Configura√ß√£o manual via `@Configuration` e `@Bean`

**Motivo:**

- ‚úÖ Controle expl√≠cito de depend√™ncias
- ‚úÖ Facilita testes unit√°rios
- ‚úÖ Documenta√ß√£o clara das depend√™ncias

**Trade-off:**

- ‚ö†Ô∏è Mais c√≥digo: Requer classe de configura√ß√£o
- ‚ö†Ô∏è Manuten√ß√£o: Mudan√ßas requerem atualiza√ß√£o manual

**Compromisso:** Trade-off aceito pela clareza e testabilidade. Em projetos maiores, considerar inje√ß√£o autom√°tica com
`@Component` e `@Service`.

---

### 6. **H2 vs PostgreSQL para Desenvolvimento**

**Decis√£o:** PostgreSQL desde o in√≠cio

**Motivo:**

- ‚úÖ Consist√™ncia: Mesmo banco em dev e produ√ß√£o
- ‚úÖ Features: Suporte completo a constraints e √≠ndices
- ‚úÖ Realismo: Testa comportamento real do banco

**Trade-off:**

- ‚ö†Ô∏è Setup: Requer instala√ß√£o/configura√ß√£o do PostgreSQL
- ‚ö†Ô∏è Portabilidade: Mais dif√≠cil para desenvolvedores iniciantes

**Compromisso:** Docker Compose resolve o problema de setup. Para desenvolvedores que preferem simplicidade, poderia ter
perfil H2 opcional.

---

## üõ†Ô∏è Tecnologias

- **Java 21** - Linguagem de programa√ß√£o
- **Spring Boot 3.5.8** - Framework principal
- **Spring Data JPA** - Persist√™ncia de dados
- **Spring Boot Actuator** - Monitoramento e gerenciamento da aplica√ß√£o
- **PostgreSQL 15** - Banco de dados relacional
- **Gradle** - Gerenciador de depend√™ncias
- **Lombok** - Redu√ß√£o de boilerplate
- **SpringDoc OpenAPI 2.7.0** - Documenta√ß√£o da API (Swagger)
- **JUnit 5** - Framework de testes

---

## üß± Entidades Criadas

### **Wallet**

Representa uma carteira digital com saldo atual, chave PIX e usu√°rio associado.

### **Transaction**

Registra todas as opera√ß√µes financeiras:

- `DEPOSIT` - Dep√≥sito na carteira
- `WITHDRAW` - Saque da carteira
- `PIX_TRANSFER_OUT` - Transfer√™ncia PIX enviada
- `PIX_TRANSFER_IN` - Transfer√™ncia PIX recebida

Status: `PENDING`, `CONFIRMED`, `REJECTED`

### **EventPix**

Registra notifica√ß√µes PIX recebidas do arranjo, garantindo idempot√™ncia via `eventId` √∫nico.

---

## ‚ö†Ô∏è Exceptions Personalizadas

- `WalletNotFoundException` - Carteira n√£o encontrada
- `PixTransferNotFoundException` - Transfer√™ncia PIX n√£o encontrada
- `InsufficientBalanceException` - Saldo insuficiente
- `UserAlreadyHasWalletException` - Usu√°rio j√° possui carteira
- `TransactionEndToEndIdAlreadyExistsException` - Transa√ß√£o duplicada
- `EventPixIdAlreadyExistsException` - Evento PIX duplicado

---

## ‚ñ∂Ô∏è Fluxo PIX (simplificado)

1. Usu√°rio inicia transfer√™ncia PIX via `POST /pix/transfers`
2. Sistema valida saldo e cria transa√ß√µes `PENDING` (d√©bito e cr√©dito)
3. Sistema retorna `endToEndId` com status `PENDING`
4. Arranjo PIX envia webhook via `POST /pix/webhook`
5. Sistema processa webhook, atualiza status e saldos se `CONFIRMED`
6. Transa√ß√µes s√£o atualizadas para `CONFIRMED` e saldos s√£o ajustados

---

## üìÅ Estrutura do Projeto

```
src/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îú‚îÄ‚îÄ java/com/lucas_cm/bank_test/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ configuration/          # Configura√ß√µes e exception handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/                 # Camada de dom√≠nio
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/          # Entidades JPA
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exceptions/        # Exce√ß√µes de dom√≠nio
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/     # Interfaces de reposit√≥rio
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/         # L√≥gica de neg√≥cio
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/        # Camada de infraestrutura
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controllers/      # Controllers REST
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ dtos/             # Data Transfer Objects
‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ       ‚îî‚îÄ‚îÄ application.properties # Configura√ß√µes da aplica√ß√£o
‚îî‚îÄ‚îÄ test/                          # Testes unit√°rios e de integra√ß√£o
```

---

## üìÑ Licen√ßa

MIT License.
